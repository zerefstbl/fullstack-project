"""Populate db tables

Revision ID: 45d238720def
Revises: 1e846fcc471e
Create Date: 2024-06-14 22:26:15.433267

"""
from typing import Sequence, Union

from alembic import op
import sqlalchemy as sa
import asyncio
from sqlalchemy.orm import Session
import httpx
from app.models.pokemon import Pokemon, Type
from asyncio import Semaphore

# revision identifiers, used by Alembic.
revision: str = '45d238720def'
down_revision: Union[str, None] = '1e846fcc471e'
branch_labels: Union[str, Sequence[str], None] = None
depends_on: Union[str, Sequence[str], None] = None

async def fetch_pokemon_data():
    url = "https://pokeapi.co/api/v2/pokemon?limit=9999999"
    async with httpx.AsyncClient() as client:
        response = await client.get(url)
        if response.status_code != 200:
            raise Exception(f"Failed to fetch data from PokeAPI: {response.status_code}")
        data = response.json()
        return data["results"]

async def fetch_pokemon_details(semaphore: Semaphore, id: str):
    async with semaphore, httpx.AsyncClient() as client:
        response = await client.get(f'https://pokeapi.co/api/v2/pokemon/{id}/')
        if response.status_code != 200:
            raise Exception(f"Failed to fetch data from PokeAPI: {response.status_code}")
        data = response.json()
        return data

def format_data(data: dict) -> dict:
    return {
        'name': data['name'],
        'front_picture': data['front_default'],
        'back_picture': data['back_default'],
        'hp': next((stat for stat in data['stats'] if stat['stat']['name'] == 'hp'), None).get('base_stat', None),
        'attack': next((stat for stat in data['stats'] if stat['stat']['name'] == 'attack'), None).get('base_stat', None),
        'defense': next((stat for stat in data['stats'] if stat['stat']['name'] == 'defense'), None).get('base_stat', None),
        'special_attack': next((stat for stat in data['stats'] if stat['stat']['name'] == 'special-attack'), None).get('base_stat', None),
        'special_defense': next((stat for stat in data['stats'] if stat['stat']['name'] == 'special-defense'), None).get('base_stat', None),
        'speed': next((stat for stat in data['stats'] if stat['stat']['name'] == 'speed'), None).get('base_stat', None),
    }

async def run_async_upgrade():
    await async_upgrade()

def upgrade() -> None:
    pass


async def async_upgrade() -> None:
    # Inicie uma nova sessão do SQLAlchemy
    bind = op.get_bind()
    session = Session(bind=bind)

    # Fetch the list of pokemons
    pokemons = await fetch_pokemon_data()

    # Create a semaphore to limit the number of simultaneous requests
    semaphore = Semaphore(10)

    # Fetch the details of each pokemon in parallel
    tasks = [fetch_pokemon_details(semaphore, pokemon["url"].split('/')[-2]) for pokemon in pokemons]
    pokemons = await asyncio.gather(*tasks)

    batch_size = 300  # Ajuste este valor para o que melhor se adequa ao seu caso
    for i, poke in enumerate(pokemons, start=1):
        data = format_data(data=poke)
        pokemon = Pokemon(**data)
        session.add(pokemon)
        session.flush()  # Sincronize a sessão para obter o ID do pokemon

        type = Type(pokemon_id=pokemon.id, name=pokemon.name)  # Substitua 'pokemon_id' pelo nome real da sua chave estrangeira
        session.add(type)

        if i % batch_size == 0:
            session.commit()  # Faça commit a cada 'batch_size' inserções
    session.commit()


def downgrade() -> None:
    # ### commands auto generated by Alembic - please adjust! ###
    pass
    # ### end Alembic commands ###
